刘子扬 2020K8009929043 作业6
6.1 某系统存在4个进程和5份可分配资源，当前的资源分配情况和最大需求如下表所示。求满足安全状态下X的最小值。请写出解题分析过程。

|           | Allocated   | Maximum     | Available   |
| --------: | :---------- | :---------- | :---------- |
| Process A | `1 0 2 1 1` | `1 1 2 1 3` | `0 0 x 1 2` |
| Process B | `2 0 1 1 0` | `2 2 2 1 0` |             |
| Process C | `1 1 0 1 0` | `2 1 3 1 0` |             |
| Process D | `1 1 1 1 0` | `1 1 2 2 1` |             |

解：

首先求出还需要分配的资源数：
|           | Need        |
| --------: | :---------- | 
| Process A | `0 1 0 0 2` |
| Process B | `0 2 1 0 0` | 
| Process C | `1 0 3 0 0` | 
| Process D | `0 0 1 1 1` | 
使用从小到大的枚举法得出x的最小值：
#### X = 0
这显然是不符合安全状态的，此时空闲资源向量为 0 0 0 1 1，其不满足任何一个还需分配的资源数。
#### X = 1
显然，第一步只能分配给D进程，D进程执行完毕后，空闲资源向量为 1 1 2 2 2。

|           | Allocated   | Maximum     | Need        | Available   |
| --------: | :---------- | :---------- | :---------- | :---------- |
| Process A | `1 0 2 1 1` | `1 1 2 1 3` | `0 1 0 0 2` | `1 1 2 2 2` |
| Process B | `2 0 1 1 0` | `2 2 2 1 0` | `0 2 1 0 0` |             |
| Process C | `1 1 0 1 0` | `2 1 3 1 0` | `1 0 3 0 0` |             |

此时可以分配给A进程，分配完毕后为：
|           | Allocated   | Maximum     | Need        | Available   |
| --------: | :---------- | :---------- | :---------- | :---------- |
| Process B | `2 0 1 1 0` | `2 2 2 1 0` | `0 2 1 0 0` | `2 1 4 3 3` |
| Process C | `1 1 0 1 0` | `2 1 3 1 0` | `1 0 3 0 0` |             |
随后可以分配给C进程，分配完毕后为：
|           | Allocated   | Maximum     | Need        | Available   |
| --------: | :---------- | :---------- | :---------- | :---------- |
| Process B | `2 0 1 1 0` | `2 2 2 1 0` | `0 2 1 0 0` | `3 2 4 4 3` |
此时分配给B进程就完成了所有进程在安全状态下的分配，最终空闲进程为5 2 5 5 3

因此，X的最小值为X = 1。

6.2 两进程A和B各需要数据库中的3份记录1、2、3，若进程A以1、2、3的顺序请求这些资源， 进程B也以同样的顺序请求这些资源，则将不会产生死锁。但若进程B以3、2、1的顺序请求这些资源，则可能会产生死锁。这3份资源存在6种可能的请求顺序，其中哪些请求顺序能保证无死锁产生？请写出解题分析过程。

对于B进程来讲，其可能的6种请求顺序为：
```
1、2、3
1、3、2
2、1、3
2、3、1
3、1、2
3、2、1
```
其中，只有前两种不会产生死锁。这是因为当A和B进程同时申请获得1号资源，那么会有一个被分配到资源，另外一个被阻塞，知道分配到资源的进程顺利执行完毕。因此，这不会被阻塞。

对于其它情况，A和B进程都会申请到至少一个资源，但二者都因此不能获得所有的资源，不会因为运行完毕释放。因此，此时A、B进程间就产生了死锁现象。